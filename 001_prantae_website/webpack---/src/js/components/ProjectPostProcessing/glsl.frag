export default "#define GLSLIFY 1\n#include <common>\nvarying vec2 vUv;\nvarying float vProgress;\n\nuniform sampler2D tDiffuse; // texture2D of the rendered scene\nuniform sampler2D uDisplaceMap;\nuniform vec2 uResolution;\nuniform float uForce;\nuniform float uProgressSide;\nuniform float uTime;\nuniform float uAccelerate;\nuniform vec3 uBgColor;\nuniform float uDirection;\nuniform float uLighten;\n\nconst float sideAngleCoef = .4;\nconst float offsetLeft = .56;\nconst float offsetTextureleft = -0.3;\nconst float speedCoef = 0.00003;\nconst float mainTextureOffsetValue = 0.17;\nconst float uvScale = 1.5;\nconst float ratioSquare = 1.;\n\nvoid main() {\n  float ratio = uResolution.y / uResolution.x;\n\n  // center UV, offset, scale...\n  vec2 uvDisplaceMap = (vUv - 0.5) * uvScale + 0.5;\n  uvDisplaceMap.y *= ratio / ratioSquare;\n  uvDisplaceMap.y += (1. - ratio / ratioSquare) / 2.;\n  uvDisplaceMap.x -= (offsetTextureleft - uAccelerate) * uDirection;\n  // animation\n  // uvDisplaceMap.x += uAccelerate * uDirection;\n  // upside down\n  uvDisplaceMap.y *= uDirection;\n  // multiply Displacement map\n\n  vec4 displace = texture2D(uDisplaceMap, uvDisplaceMap);\n\n  // Separation\n  float separation = 1. - vUv.y * sideAngleCoef * uDirection;\n\n  // smoothstep value from left to right for border fading\n  float amplificationForce = (1. - vUv.x - offsetLeft) * separation + vProgress;\n  if (uDirection == -1.) {\n    amplificationForce =(vUv.x - offsetLeft) * separation - vProgress;\n  }\n  amplificationForce = min(0.15, amplificationForce);\n  float coefForceUV = min(20., smoothstep(0.0, 1., amplificationForce));\n\n  // displacement\n  // increase the displacement exp from right to left\n  float powValue = 1.2;\n  float expForceX = pow((1. + (1. - vUv.x)), powValue);\n  if (uDirection == -1.) {\n    expForceX = pow((1. + (vUv.x)), powValue);\n  }\n  float displaceK = min(5., displace.g * uForce * coefForceUV / 20. * expForceX);\n\n  // Separation effect added\n\n  if (uDirection == -1. && vUv.x > offsetLeft * separation + vProgress\n  || uDirection == 1. && vUv.x < (1. - offsetLeft) * separation + vProgress) {\n    vec2 uvDisplaced = vec2((1. - vUv.x) - displaceK * uDirection, vUv.y);\n    gl_FragColor = texture2D(tDiffuse, uvDisplaced);\n    gl_FragColor.r = clamp(gl_FragColor.r, uBgColor.r, 1.0);\n    gl_FragColor.g = clamp(gl_FragColor.g, uBgColor.g, 1.0);\n    gl_FragColor.b = clamp(gl_FragColor.b, uBgColor.b, 1.0);\n    // ligthen\n    vec3 white = vec3(1.0);\n    gl_FragColor = vec4(mix(gl_FragColor.rgb, white, uLighten), 1.);\n  } else {\n    vec2 uvDisplaced = vec2(vUv.x, vUv.y);\n    gl_FragColor = texture2D(tDiffuse, uvDisplaced);\n  }\n}\n";