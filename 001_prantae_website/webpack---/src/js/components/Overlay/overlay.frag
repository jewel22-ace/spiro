export default "precision highp float;\n#define GLSLIFY 1\n\nuniform float uProgress;\nuniform vec2 uSize;\nuniform float uZoom;\nuniform bool uReverse;\nuniform vec3 uColor;\n\nvarying vec2 vUv;\n\nfloat circle(vec2 uv, float radius) {\n\tfloat border = 0.02;\n\tfloat dist = radius - distance(uv, vec2(0.5));\n  // top right corner\n  float distTR = radius - distance(uv - vec2(1.0 / 3.0, 1.0), vec2(0.5));\n  float tr = smoothstep(0.0, border, distTR);\n\n  // top left corner\n  float distTL = radius - distance(uv - vec2(-2.0 / 3.0, 1.0), vec2(0.5));\n  float tl = smoothstep(0.0, border, distTL);\n\n  // bottom right corner\n  float distBR = radius - distance(uv - vec2(2.0 / 3.0, -1.0), vec2(0.5));\n  float br = smoothstep(0.0, border, distBR);\n\n  // bottom left corner\n  float distBL = radius - distance(uv - vec2(-1.0 / 3.0, -1.0), vec2(0.5));\n  float bl = smoothstep(0.0, border, distBL);\n\n  float center = smoothstep(0.0, border, dist);\n\n  return center + tr + tl + br + bl;\n}\n\nvoid main() {\n  // Circles fill animation\n\n  // Set up grid\n  vec2 grid = vec2(vUv.x * uSize.x, vUv.y * uSize.y) * uZoom;\n  // offset on 3 parts\n  grid.x += step(1.0, mod(grid.y, 3.0)) * 2.0 / 3.0;\n  grid.x += step(1.0, mod(grid.y + 1.0, 3.0)) * 1.0 / 3.0;\n  // grid.x += step(1.0, mod(grid.y, 2.0)) * 0.5;\n\n  grid = fract(grid); // Wrap around 1.0\n\n  // progress\n  float uvXY = (vUv.x + vUv.y) / 2.0;\n  float progress;\n\n  if (uReverse) {\n    progress = 1.0 + uvXY - (uProgress * 2.0);\n  } else {\n    progress = (1.0 - uvXY) - (1.0 - uProgress * 2.0);\n  }\n\n  float alpha = circle(grid, progress);\n\n  gl_FragColor = vec4(uColor, alpha);\n}\n";