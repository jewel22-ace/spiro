export default "precision highp float;\n#define GLSLIFY 1\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nuniform vec3 uLightColor[3];\nuniform vec3 uColor;\nuniform float uLightIntensity;\nuniform float uNoiseCoef;\nuniform float uNoiseMin;\nuniform float uNoiseMax;\nuniform vec3 uBgColor;\n// uniform float uTime;\nuniform bool uAlpha;\nuniform bool uPattern;\nuniform bool uPlain;\nuniform float uFract;\nuniform vec2 uResolution;\n\nvarying vec3 vNormal;\nvarying vec3 vVertex;\nvarying vec3 vLightPos[3];\nvarying vec2 vUv;\n\n//-------------------------------------------------------------------------\n// Given a normal vector and a light,\n// calculate the fragment's color using diffuse and specular lighting.\nvec3 light_calculations(vec3 fragment_normal, vec3 lightPos, vec3 lightColor) {\n\n  vec3 diffuse_color;\n  vec3 to_light;\n  float cos_angle;\n  vec3 color;\n\n  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  // General calculations needed for both specular and diffuse lighting\n\n  // Calculate a vector from the fragment location to the light source\n  to_light = lightPos - vVertex;\n  to_light = normalize( to_light );\n\n  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  // DIFFUSE  calculations\n\n  // Calculate the cosine of the angle between the vertex's normal\n  // vector and the vector going to the light.\n  cos_angle = dot(fragment_normal, to_light);\n  cos_angle = clamp(cos_angle, 0.0, 1.0);\n\n  // Scale the color of this fragment based on its angle to the light.\n  diffuse_color = uColor * lightColor * cos_angle * uLightIntensity;\n\n  // Combine\n  color = diffuse_color;\n\n  return color;\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat lines(in vec2 pos, float b){\n    float scale = 10.0;\n    pos *= scale;\n    return smoothstep(0.0,\n                    .5+b*.5,\n                    abs((sin(pos.x*3.1415)+b*2.0))*.5);\n}\n\nvoid main(void) {\n  float ambient = uLightIntensity;\n  vec3 normal = normalize(vNormal);\n  vec3 color = uColor;\n\n  // for each light...\n  for(int i = 0; i < 3; i++) {\n    color = color + light_calculations(normal, vLightPos[i], uLightColor[i]);\n  }\n\n  // Add ambient light intensity\n  color *= ambient;\n\n  // grain\n  // Calculate noise and sample texture\n  // color.g = light intensity\n  float lightValue = color.r;\n\n  if (uPattern) {\n    // uv Pattern\n    vec2 pos = vUv;\n      // pos = st.yx * vec2(10.,10.);\n\n    float pattern = pos.x;\n\n    // Add noise\n    pos = rotate2d( snoise(pos) * uFract ) * pos;\n\n    // Draw lines\n    pattern = lines(pos, .5);\n    gl_FragColor = vec4(vec3(pattern * lightValue), 1.);\n\n  } else if (uPlain){\n    // plain\n    gl_FragColor = vec4(vec3(0.45 * lightValue), 1.);\n  } else {\n    // grain\n    float mdf = clamp(uNoiseMin, uNoiseMax, pow(lightValue, uNoiseCoef));\n    vec2 st = gl_FragCoord.xy / uResolution.xy;\n    st *= 55.; // old 555\n\n    vec3 textureNoise = vec3(snoise(st) * .5 + .5);\n    textureNoise *= mdf;\n\n    gl_FragColor = vec4(textureNoise, 1.);\n  }\n\n  if (uAlpha) {\n    gl_FragColor.a = 1.0 - gl_FragColor.r;\n  }\n\n  // // clamping color values\n  // old value 0.3\n\n  if (uPattern) {\n    gl_FragColor.r = clamp(gl_FragColor.r, .45, 1.0);\n    gl_FragColor.g = clamp(gl_FragColor.g, .45, 1.0);\n    gl_FragColor.b = clamp(gl_FragColor.b, .45, 1.0);\n  } else {\n    gl_FragColor.r = clamp(gl_FragColor.r, uBgColor.r, 1.0);\n    gl_FragColor.g = clamp(gl_FragColor.g, uBgColor.g, 1.0);\n    gl_FragColor.b = clamp(gl_FragColor.b, uBgColor.b, 1.0);\n  }\n\n  // if (gl_FragColor.r < 0.5) {\n  //   gl_FragColor.r = 206.0 / 255.0;\n  //   gl_FragColor.g = 217.0 / 255.0;\n  //   gl_FragColor.b = 255.0 / 255.0;\n  // }\n  // gl_FragColor = vec4(color, 1.0);\n\n}\n";