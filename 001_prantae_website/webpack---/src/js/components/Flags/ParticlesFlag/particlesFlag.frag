export default "precision highp float;\n#define GLSLIFY 1\n\n// circle\nfloat circle(vec2 uv, float border) {\n\tfloat radius = 0.5;\n\tfloat dist = radius - distance(uv, vec2(0.5));\n  return smoothstep(0.0, border, dist);\n}\n\nuniform sampler2D uTexture;\nuniform sampler2D uTextureNext;\nuniform vec2 uTextureSize;\nuniform float uTransitionProgress;\nuniform float uAlpha;\nuniform float uMaxAlpha;\nuniform float uScale;\n// uniform bool uMenuView;\nuniform vec3 uColor;\nuniform float uMenuViewHoverProgress;\nuniform float uMenuViewProgress;\nuniform float uTextureLoadProgress;\nuniform float uTime;\n\nvarying float vPointScale;\nvarying vec2 vTexCoords;\nvarying float vStormProgress;\nvarying float vAlphaTouch;\nvarying vec2 vUv;\n\n#define HALF_PI 3.1415926538 / 2.0\n#define PI 3.1415926538\n\nfloat createLoaderPoint(float angle, float index, vec2 uTextureSize, vec2 uv) {\n  float pointSize = uTextureSize.x * 0.03;\n  pointSize *= (index / 2. + 1.) * 1. / 8.;\n  float innerSpace = 10.;\n  // vec2 st = uv.xy / uTextureSize.xy;\n  float ratio = uTextureSize.y / uTextureSize.x;\n\tfloat Ldist = pointSize - distance(uv * uTextureSize, vec2((0.5 + cos(angle) / innerSpace) * uTextureSize.x, (0.5 * ratio - sin(angle) / innerSpace) * uTextureSize.x) );\n  float L = smoothstep(0.0, 0.01 * uTextureSize.x / 2., Ldist);\n  return L;\n}\n\nvoid main() {\n  vec2 uv = vec2(0.0);\n\n  // adapt UVs based on point size and position\n  uv = gl_PointCoord * vec2(1.0, -1.0);\n\n  float texRepeatU = uTextureSize.x / vPointScale;\n  float texRepeatV = uTextureSize.y / vPointScale;\n  uv /= vec2(texRepeatU, texRepeatV);\n\n  float texOffsetU = vTexCoords.x / uTextureSize.x + 0.5;\n  float texOffsetV = vTexCoords.y / uTextureSize.y + 0.5;\n\n  uv += vec2(texOffsetU, texOffsetV);\n  uv += vec2(-0.5 * vPointScale / uTextureSize.x, 0.5 * vPointScale / uTextureSize.y);\n\n  // change texture when transitioning\n  vec4 texture;\n  float uvXY = (vUv.x + vUv.y) / 2.0;\n  if (uvXY * (1.0 - (HALF_PI - 1.0)) + (HALF_PI - 1.0) / 2.0 > 1.0 - uTransitionProgress) {\n    texture = texture2D(uTextureNext, uv);\n  } else {\n    texture = texture2D(uTexture, uv);\n  }\n\n  vec4 textureAppearColors = vec4(uColor * (1.0 - uTextureLoadProgress) + texture.rgb * uTextureLoadProgress, 1.0);\n\n  // hover color effect\n  vec4 hoverEffect = vec4(uColor * (1.0 - uMenuViewHoverProgress) + textureAppearColors.rgb * uMenuViewHoverProgress, 1.);\n  textureAppearColors = textureAppearColors * (1.0 - uMenuViewProgress) + hoverEffect * uMenuViewProgress;\n\n  gl_FragColor = vec4(textureAppearColors.rgb, 1.);\n\n  // loader\n  if (uTextureLoadProgress < 1.) {\n    float divider = 2. / 8.;\n    float L1 = createLoaderPoint(0. + uTime, 0., uTextureSize, uv);\n    float L2 = createLoaderPoint(PI * divider + uTime, 1., uTextureSize, uv);\n    float L3 = createLoaderPoint(PI * 2. * divider + uTime, 2., uTextureSize, uv);\n    float L4 = createLoaderPoint(PI * 3. * divider + uTime, 3., uTextureSize, uv);\n    float L5 = createLoaderPoint(PI * 4. * divider + uTime, 4., uTextureSize, uv);\n    float L6 = createLoaderPoint(PI * 5. * divider + uTime, 5., uTextureSize, uv);\n    float L7 = createLoaderPoint(PI * 6. * divider + uTime, 6., uTextureSize, uv);\n    float L8 = createLoaderPoint(PI * 7. * divider + uTime, 7., uTextureSize, uv);\n    gl_FragColor.rgb += (1.0 - uTextureLoadProgress) * (L1 + L2 + L3 + L4 + L5 + L6 + L7 + L8);\n  }\n\n  // gl_FragColor.a -= 1.0 - vStormProgress;\n  // Points and alpha\n  gl_FragColor.a *= circle(gl_PointCoord, 0.05 - 0.03 * uMenuViewProgress);\n  gl_FragColor.a *= vAlphaTouch;\n  gl_FragColor.a *= uAlpha;\n  gl_FragColor.a *= uMaxAlpha;\n\n  // discard edges\n  if (vStormProgress > 0.9) { // && uSpread < 0.1\n   if (uv.x > 1.0 || uv.x < 0.0 || uv.y > 1.0 || uv.y < 0.0) {\n      // gl_FragColor.a = smoothstep(0.0, 1.0, 1.0 - uv.x);\n      discard;\n    }\n  }\n}\n";